#include "Utils.h"
#include <iostream>
#include <windows.h>
#include <winspool.h>
#include <string>
#include <vector>

std::string Utils::EnteringInformation() 
{
    std::string age;
    std::cout << "Entrez votre âge: ";
    std::cin >> age;

    return age;
}


void Utils::DisplayInformation(std::string age)
{
    std::cout << "Âge de l'utilisateur : " << age << std::endl;
}


void Utils::WriteInTxtFile(std::string data) 
{

}


void Utils::Printing()
{
    DWORD dwSize = 0;
    GetDefaultPrinter(NULL, &dwSize);

    // Allocate memory for the default printer name
    wchar_t* pszDefaultPrinter = new wchar_t[dwSize];

    // Retrieve the default printer name
    if (GetDefaultPrinter(pszDefaultPrinter, &dwSize)) {
        std::wcout << L"Default Printer: " << pszDefaultPrinter << std::endl;
    }
    else {
        std::cerr << "Failed to retrieve default printer name." << std::endl;
    }  
    
    HANDLE handlePrinter = NULL;
    LPHANDLE lphandlePrinter = &handlePrinter;

    wchar_t printerName = NULL;
    LPTSTR pprinterName = &printerName;

    PRINTER_DEFAULTS printerDefaults;
    printerDefaults.pDatatype = NULL;
    printerDefaults.pDevMode = NULL;
    printerDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    bool isOpenPrinterWorks = OpenPrinter(pszDefaultPrinter, lphandlePrinter, NULL);

    if (!isOpenPrinterWorks) 
    {
        std::wcout << L"Error - OpenPrinter function!" << std::endl;
        return;
    }

    DWORD level = 1;

    char data[] = "Test";
    DWORD dataSize = sizeof(data);

    DOC_INFO_1 docInfo;

    const wchar_t* docName = L"Age";
    LPTSTR lpDocName = const_cast<LPTSTR>(docName);

    const wchar_t* dataType = L"TEXT";
    LPTSTR lpDataType = const_cast<LPTSTR>(dataType);

    docInfo.pOutputFile = NULL;
    docInfo.pDocName = lpDocName;
    docInfo.pDatatype = lpDataType;

    /*DWORD bufferSize = sizeof(DOC_INFO_1);*/

    /*LPBYTE lpBuffer = (LPBYTE)malloc(bufferSize);
    if (lpBuffer == NULL) {
        std::cerr << "Memory allocation failed." << std::endl;
        return;
    }*/

    // Copy the content of the DOC_INFO_1 structure to the buffer
    /*memcpy(lpBuffer, &docInfo, bufferSize);*/

    // -1-
    DWORD printJob = StartDocPrinter(handlePrinter, level, (LPBYTE)&docInfo);

    // -2-
    bool isStartPagePrinterWorks = StartPagePrinter(handlePrinter);

    // -3-
    DWORD bytesWritten = 0;

    WritePrinter(handlePrinter, (LPVOID)data, dataSize, &bytesWritten);

    /*if (!WritePrinter(handlePrinter, (LPVOID)data, dataSize, &bytesWritten)) {
        std::cerr << "Failed to write to printer." << std::endl;
        ClosePrinter(handlePrinter);
        return;
    }*/

    // -4-
    bool isEndPagePrinterWorks = EndPagePrinter(handlePrinter);

    // -5-
    bool isEndDocPrinterWorks = EndDocPrinter(handlePrinter);

    // Close the printer handle
    ClosePrinter(handlePrinter);
    delete[] pszDefaultPrinter;
}


//void Utils::Printing()
//{
//    TCHAR szPrinterName[MAX_PATH];
//    DWORD dwBufferSize = sizeof(szPrinterName) / sizeof(szPrinterName[0]);
//    LPTSTR printerName = szPrinterName;
//    BOOL test = GetDefaultPrinter(printerName, &dwBufferSize);
//
//    HANDLE hPrinter;
//    /*BOOL bStatus = OpenPrinter((LPTSTR) szPrinterName, &hPrinter, NULL);*/
//    BOOL bStatus = OpenPrinter(printerName, &hPrinter, NULL);
//    if (!bStatus) {
//        return;
//    }
//
//    DOC_INFO_1 docInfo;
//    docInfo.pDocName = (LPTSTR) L"My Document";
//    docInfo.pOutputFile = NULL;
//    docInfo.pDatatype = (LPTSTR) L"RAW";
//    DWORD level = 1;
//    /*LPBYTE pdocInfo = (LPBYTE)&docInfo;*/
//
//    /*DWORD dwJob = StartDocPrinter(hPrinter, level, (LPBYTE)&docInfo);
//    if (dwJob == 0) {
//        DWORD dwError = GetLastError();
//        ClosePrinter(hPrinter);
//        return;
//    }*/
//
//    char input[] = "test";
//    DWORD inputSize = sizeof(input);
//    DWORD dwBytesWritten = 0;
//
//    BOOL resultPage1 = StartPagePrinter(hPrinter);
//    bStatus = WritePrinter(hPrinter, input, inputSize, &dwBytesWritten);
//    BOOL resultPage2 = EndPagePrinter(hPrinter);
//
//    if (!bStatus || dwBytesWritten == 0) {
//        EndDocPrinter(hPrinter);
//        ClosePrinter(hPrinter);
//        return;
//    }
//
//    /*EndDocPrinter(hPrinter);*/
//    ClosePrinter(hPrinter);
//
//    std::wcout << L"Print job sent to printer." << std::endl;
//
//    //TCHAR szPrinterName[MAX_PATH];
//    //DWORD dwBufferSize = sizeof(szPrinterName) / sizeof(szPrinterName[0]);
//
//    //char docName[] = "test";
//    //char docType[] = "test.txt";
//    //char docOut[] = "";
//
//    //LPCSTR lpszDocName = "test";
//
//
//    //if (GetDefaultPrinter(szPrinterName, &dwBufferSize)) {
//    //    
//    //    // Get a handle to the default printer
//    //    HDC printerDC = ::CreateDC(TEXT("DISPLAY"), nullptr, nullptr, nullptr);
//    //    /*HDC printerDC = ::CreateDC(L"WINSPOOL", szPrinterName, nullptr, nullptr);*/
//
//    //    if (printerDC == nullptr) {
//    //        // Handle error
//    //        return;
//    //    }
//    //    int sizebit = 20;
//
//    //    DOCINFOA doc(sizebit, lpszDocName, nullptr, nullptr, 0);
//    //    ///*::TextOut(printerDC, 100, 100, textToPrint, wcslen(textToPrint));*/
//
//    //    //::DeleteDC(printerDC);
//    //}
//    //else {
//    //    DWORD dwError = GetLastError();
//    //    std::cerr << "Failed to get default printer. Error code: " << dwError << std::endl;
//    //}
//}
